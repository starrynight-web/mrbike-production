# ðŸš€ **ULTIMATE MRBIKEBD MASTER PROMPT - IDE VERSION**

## **ENGINEERING CONTEXT & IMMEDIATE PRIORITIES**

### **PROJECT STATUS CRISIS SUMMARY:**
```
FRONTEND: 85% Complete (UI/UX polished, static data)
BACKEND:  15% Complete (Skeleton only, no working APIs)
DATABASE: 10% Complete (Models defined, empty databases)
AUTH:      5% Complete (Mocked only)
CRITICAL: System is FRONTEND-HEAVY with NO backend functionality
```

### **IMMEDIATE SURVIVAL TRIAGE (NEXT 48 HOURS):**
```bash
# 1. FIX BACKEND-API DISCONNECT
# Current: Frontend â†’ Static JSON â†’ UI
# Required: Frontend â†’ API Calls â†’ Django â†’ PostgreSQL/MongoDB

# 2. CREATE ESSENTIAL APIS (MUST-HAVES):
POST /api/auth/google/        # Google OAuth endpoint
GET  /api/bikes/              # Bike listing with filters
GET  /api/bikes/{slug}/       # Bike detail with recommendations
POST /api/used-bikes/         # Create used bike listing (with phone verification)
GET  /api/used-bikes/         # Browse listings
```

### **3-PHASE RESCUE PLAN:**

**PHASE 1A (CRITICAL): Backend-Frontend Bridge**
```python
# DEADLINE: 7 DAYS
# TASKS:
1. Migrate bike data from JSON â†’ PostgreSQL + MongoDB
2. Implement NextAuth.js â†” Django JWT authentication
3. Create minimum viable API endpoints
4. Replace ALL static JSON imports with API calls
5. Basic Redis caching setup
```

**PHASE 1B (ESSENTIAL): Core Functionality**
```python
# DEADLINE: 14 DAYS
# TASKS:
1. Complete emotional recommendation engine
2. User profile system (wishlist, reviews, listings)
3. Admin moderation panel
4. Phone OTP verification flow
5. Image upload to Cloudinary
```

**PHASE 2 (MONETIZATION):**
```python
# DEADLINE: 30 DAYS
# TASKS:
1. SSLCommerz payment integration
2. Premium subscriptions
3. React Native mobile app
4. Advanced analytics
5. Bengali language support
```

---

## **TECHNICAL ARCHITECTURE MASTER REFERENCE**

### **DATABASE STRATEGY:**
```
PRIMARY (PostgreSQL/Supabase):
- Users, profiles, authentication
- Used bike listings
- Wishlists, reviews, transactions
- Subscriptions, payments
- Admin/moderation data

SECONDARY (MongoDB Atlas):
- Bike catalog (300+ bikes)
- News articles, blog posts
- Flexible specs/variants data
- Recommendation engine data
- SEO metadata

CACHE (Redis):
- Bike pages (15 min TTL)
- Recommendations (10 min TTL)
- Search queries (5 min TTL)
- API rate limiting
- Session storage
```

### **AUTHENTICATION FLOW:**
```mermaid
User â†’ Google OAuth (NextAuth) â†’ JWT Token â†’ Django Backend â†’ Create/Get User in PostgreSQL
â†“
Phone OTP (Firebase) â†’ Verify â†’ Update User (phone_verified=True) â†’ Enable posting permissions
â†“
Session (JWT cookies) â†’ Protected APIs â†’ Authorization middleware
```

---

## **CRITICAL IMPLEMENTATION SCRIPTS**

### **SCRIPT 1: BIKE DATA MIGRATION (MOST URGENT)**
```python
# Location: backend/scripts/migrate_bikes.py
import json
import django
import os
import sys

# Setup Django
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'mrbikebd.settings')
django.setup()

from apps.bikes.models import Bike, Brand, BikeVariant
from pymongo import MongoClient
from django.conf import settings

def migrate_json_to_databases():
    """
    Migrate 300 bikes from frontend JSON to:
    1. PostgreSQL (core bike info, brand, pricing)
    2. MongoDB (detailed specs, variants, flexible data)
    """
    
    # Load bikes.json from frontend
    with open('../frontend/src/data/bikes.json', 'r') as f:
        bikes_data = json.load(f)
    
    print(f"Found {len(bikes_data)} bikes to migrate")
    
    # Connect to MongoDB Atlas
    mongo_client = MongoClient(settings.MONGODB_URI)
    mongo_db = mongo_client['mrbikebd']
    mongo_bikes = mongo_db['bikes']
    
    migrated_count = 0
    
    for bike_json in bikes_data:
        try:
            # 1. PostgreSQL: Create Brand if not exists
            brand, _ = Brand.objects.get_or_create(
                name=bike_json['brand'],
                defaults={'slug': bike_json['brand'].lower().replace(' ', '-')}
            )
            
            # 2. PostgreSQL: Create Bike entry
            bike, created = Bike.objects.get_or_create(
                slug=bike_json['slug'],
                defaults={
                    'name': bike_json['name'],
                    'brand': brand,
                    'category': bike_json.get('category', 'commuter'),
                    'price_min': bike_json['price_range']['min'],
                    'price_max': bike_json['price_range']['max'],
                    'engine_cc': bike_json.get('engine_cc', 150),
                    'mileage': bike_json.get('mileage', 35),
                    'top_speed': bike_json.get('top_speed', 100),
                    'resale_score': bike_json.get('resale_score', 7.0),
                }
            )
            
            # 3. MongoDB: Store detailed specs
            mongo_data = {
                'postgres_id': str(bike.id),
                'slug': bike_json['slug'],
                'full_specs': bike_json.get('specs', {}),
                'variants': bike_json.get('variants', []),
                'images': bike_json.get('images', []),
                'description': bike_json.get('description', ''),
                'features': bike_json.get('features', []),
                'created_at': django.utils.timezone.now(),
                'updated_at': django.utils.timezone.now()
            }
            
            # Upsert to MongoDB
            mongo_bikes.update_one(
                {'slug': bike_json['slug']},
                {'$set': mongo_data},
                upsert=True
            )
            
            migrated_count += 1
            print(f"âœ“ Migrated: {bike.name}")
            
        except Exception as e:
            print(f"âœ— Failed {bike_json.get('name', 'Unknown')}: {str(e)}")
    
    print(f"\nMigration complete: {migrated_count}/{len(bikes_data)} bikes migrated")
    
if __name__ == "__main__":
    migrate_json_to_databases()
```

### **SCRIPT 2: BACKEND API SKELETON GENERATOR**
```python
# Location: backend/scripts/generate_apis.py
import os
from pathlib import Path

API_TEMPLATE = '''"""
AUTO-GENERATED API VIEW
Generated for: {model_name}
"""

from rest_framework import generics, permissions, status
from rest_framework.response import Response
from rest_framework.views import APIView
from django.core.cache import cache
import json

from .models import {model_name}
from .serializers import {model_name}Serializer

class {model_name}ListView(generics.ListAPIView):
    """List all {model_name}s with filtering"""
    queryset = {model_name}.objects.all()
    serializer_class = {model_name}Serializer
    permission_classes = [permissions.AllowAny]
    
    @method_decorator(cache_page(60 * 15))  # 15 minutes cache
    def get(self, request, *args, **kwargs):
        return super().get(request, *args, **kwargs)
    
    def get_queryset(self):
        queryset = super().get_queryset()
        # Add filters here
        return queryset

class {model_name}DetailView(generics.RetrieveAPIView):
    """Get single {model_name}"""
    queryset = {model_name}.objects.all()
    serializer_class = {model_name}Serializer
    permission_classes = [permissions.AllowAny]
    lookup_field = 'slug'
    
    @method_decorator(cache_page(60 * 30))  # 30 minutes cache
    def get(self, request, *args, **kwargs):
        return super().get(request, *args, **kwargs)

class {model_name}CreateView(generics.CreateAPIView):
    """Create new {model_name}"""
    queryset = {model_name}.objects.all()
    serializer_class = {model_name}Serializer
    permission_classes = [permissions.IsAuthenticated]
'''

def generate_api_files():
    models = ['Bike', 'UsedBike', 'Wishlist', 'Review', 'UserProfile']
    
    for model in models:
        views_content = API_TEMPLATE.format(model_name=model)
        
        # Create directory if not exists
        views_dir = Path(f"backend/apps/{model.lower()}s/views.py")
        views_dir.parent.mkdir(parents=True, exist_ok=True)
        
        # Write views.py
        with open(views_dir, 'w') as f:
            f.write(views_content)
        
        print(f"Generated API for: {model}")
        
        # Generate URLs
        urls_content = f'''from django.urls import path
from .views import *

urlpatterns = [
    path('', {model}ListView.as_view(), name='{model.lower()}-list'),
    path('<slug:slug>/', {model}DetailView.as_view(), name='{model.lower()}-detail'),
    path('create/', {model}CreateView.as_view(), name='{model.lower()}-create'),
]
'''
        
        urls_dir = Path(f"backend/apps/{model.lower()}s/urls.py")
        with open(urls_dir, 'w') as f:
            f.write(urls_content)
        
        print(f"Generated URLs for: {model}")

if __name__ == "__main__":
    generate_api_files()
```

---

## **FRONTEND-BACKEND CONNECTION FIX**

### **UNIFIED API SERVICE (CRITICAL)**
```typescript
// Location: frontend/src/lib/api-service.ts
import axios from 'axios';
import { getSession } from 'next-auth/react';

const API_BASE = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';

class ApiService {
  private client;
  
  constructor() {
    this.client = axios.create({
      baseURL: API_BASE,
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      }
    });
    
    // Request interceptor for auth token
    this.client.interceptors.request.use(async (config) => {
      const session = await getSession();
      if (session?.accessToken) {
        config.headers.Authorization = `Bearer ${session.accessToken}`;
      }
      return config;
    });
  }
  
  // AUTH API
  async googleAuth(token: string) {
    return this.client.post('/api/auth/google/', { token });
  }
  
  async verifyPhoneOTP(phone: string, otp: string) {
    return this.client.post('/api/auth/verify-phone/', { phone, otp });
  }
  
  // BIKE API
  async getBikes(filters?: any) {
    const params = new URLSearchParams(filters).toString();
    return this.client.get(`/api/bikes/?${params}`);
  }
  
  async getBikeBySlug(slug: string) {
    return this.client.get(`/api/bikes/${slug}/`);
  }
  
  async getSimilarBikes(slug: string) {
    return this.client.get(`/api/bikes/${slug}/similar/`);
  }
  
  // USED BIKES API
  async createListing(listingData: any) {
    return this.client.post('/api/used-bikes/', listingData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  }
  
  async getListings(filters?: any) {
    const params = new URLSearchParams(filters).toString();
    return this.client.get(`/api/used-bikes/?${params}`);
  }
  
  // USER API
  async getWishlist() {
    return this.client.get('/api/wishlist/');
  }
  
  async toggleWishlist(bikeId: string) {
    return this.client.post(`/api/wishlist/${bikeId}/`);
  }
  
  async submitReview(bikeId: string, rating: number) {
    return this.client.post(`/api/reviews/${bikeId}/`, { rating });
  }
  
  // HEALTH CHECK
  async healthCheck() {
    try {
      const response = await this.client.get('/health/');
      return response.status === 200;
    } catch {
      return false;
    }
  }
}

export const api = new ApiService();
```

---

## **RECOMMENDATION ENGINE IMPLEMENTATION**

### **EMOTIONAL RECOMMENDATION ALGORITHM**
```python
# Location: backend/apps/recommendations/engine.py
import redis
import json
from django.conf import settings
from apps.bikes.models import Bike
from pymongo import MongoClient

class EmotionalRecommendationEngine:
    def __init__(self):
        self.redis_client = redis.Redis.from_url(settings.REDIS_URL)
        self.mongo_client = MongoClient(settings.MONGODB_URI)
        self.mongo_db = self.mongo_client['mrbikebd']
    
    def get_similar_bikes(self, bike_slug: str, user_id=None, limit=4):
        """
        RULE-BASED SIMILAR BIKE RECOMMENDATIONS
        
        Bangladesh-specific rules:
        1. Same category (must match)
        2. Price range Â±15% (flexible for emotional appeal)
        3. Engine CC Â±20% (Bangladesh road suitability)
        4. Resale score priority (highly valued in BD)
        5. Fuel efficiency weighting (petrol price consideration)
        6. Brand trust factor (Honda/Yamaha premium)
        """
        
        cache_key = f"recommendations:similar:{bike_slug}"
        cached = self.redis_client.get(cache_key)
        
        if cached:
            return json.loads(cached)
        
        try:
            # Get base bike from PostgreSQL
            base_bike = Bike.objects.get(slug=bike_slug)
            
            # Get detailed specs from MongoDB
            mongo_bike = self.mongo_db.bikes.find_one({'slug': bike_slug})
            
            # RULE 1: Same category (mandatory)
            same_category = Bike.objects.filter(category=base_bike.category)
            
            # RULE 2: Price range (Â±15%)
            price_min = base_bike.price_min * 0.85
            price_max = base_bike.price_max * 1.15
            
            # RULE 3: Engine CC range (Â±20%)
            if base_bike.engine_cc:
                cc_min = base_bike.engine_cc * 0.8
                cc_max = base_bike.engine_cc * 1.2
                
            # Build query with weighted scoring
            candidates = []
            for bike in same_category.exclude(slug=bike_slug):
                score = 0
                
                # Price proximity score (30% weight)
                price_proximity = 1 - abs(bike.price_min - base_bike.price_min) / base_bike.price_min
                score += price_proximity * 0.3
                
                # Resale score (25% weight) - HIGH in Bangladesh
                resale_factor = bike.resale_score / 10.0
                score += resale_factor * 0.25
                
                # Brand premium factor (20% weight)
                brand_premium = self._get_brand_premium(bike.brand.name)
                score += brand_premium * 0.2
                
                # Fuel efficiency (15% weight) - Petrol prices high
                mileage_factor = min(bike.mileage / 50.0, 1.0)  # Cap at 50 kmpl
                score += mileage_factor * 0.15
                
                # Engine CC similarity (10% weight)
                if base_bike.engine_cc and bike.engine_cc:
                    cc_similarity = 1 - abs(bike.engine_cc - base_bike.engine_cc) / base_bike.engine_cc
                    score += cc_similarity * 0.1
                
                candidates.append({
                    'bike': bike,
                    'score': score,
                    'reasons': self._generate_reasons(bike, base_bike)
                })
            
            # Sort by score and take top N
            candidates.sort(key=lambda x: x['score'], reverse=True)
            recommendations = candidates[:limit]
            
            # Format response with emotional triggers
            result = []
            for rec in recommendations:
                result.append({
                    'slug': rec['bike'].slug,
                    'name': rec['bike'].name,
                    'price': rec['bike'].price_min,
                    'score': rec['score'],
                    'emotional_triggers': rec['reasons'],
                    'call_to_action': self._generate_cta(rec['bike'])
                })
            
            # Cache for 10 minutes
            self.redis_client.setex(cache_key, 600, json.dumps(result))
            
            return result
            
        except Bike.DoesNotExist:
            return []
    
    def _get_brand_premium(self, brand_name):
        """Bangladesh-specific brand trust factors"""
        brand_tiers = {
            'Honda': 1.0, 'Yamaha': 0.95, 'Suzuki': 0.85,
            'Bajaj': 0.8, 'TVS': 0.75, 'Hero': 0.7,
            'Runner': 0.6, 'Atlas': 0.5
        }
        return brand_tiers.get(brand_name, 0.5)
    
    def _generate_reasons(self, bike, base_bike):
        """Generate emotional reasons for recommendation"""
        reasons = []
        
        if bike.resale_score > base_bike.resale_score + 1:
            reasons.append("Better resale value")
        
        if bike.mileage > base_bike.mileage + 5:
            reasons.append("More fuel efficient")
        
        if bike.price_min < base_bike.price_min:
            reasons.append("More affordable")
        
        if not reasons:
            reasons.append("Similar performance with trusted brand")
        
        return reasons[:3]
    
    def _generate_cta(self, bike):
        """Generate emotional call-to-action"""
        ctas = [
            f"Perfect for Dhaka traffic",
            f"Great value for money",
            f"Trusted by {bike.brand.name} owners",
            f"Low maintenance costs",
            f"Easy to ride in Bangladesh roads"
        ]
        return ctas[hash(bike.slug) % len(ctas)]

# Usage in views.py
engine = EmotionalRecommendationEngine()
similar_bikes = engine.get_similar_bikes("honda-cbr-150r")
```

---

## **DEPLOYMENT READINESS CHECKLIST**

### **MINIMUM VIABLE PRODUCTION (MVP) REQUIREMENTS**
```yaml
Before Public Launch - MUST HAVE:

Backend:
- [ ] Functional API endpoints (bikes, auth, used-bikes)
- [ ] Database migration complete (300 bikes loaded)
- [ ] Redis caching operational
- [ ] JWT authentication working
- [ ] Phone OTP verification
- [ ] Basic admin panel
- [ ] Error monitoring (Sentry)

Frontend:
- [ ] All API calls migrated from static JSON
- [ ] Loading/error states implemented
- [ ] Image optimization (Cloudinary)
- [ ] SEO metadata on all pages
- [ ] Mobile responsive tested
- [ ] Performance audits passed

Infrastructure:
- [ ] Vercel deployment (frontend)
- [ ] DigitalOcean droplet (backend)
- [ ] Domain configured (mrbikebd.com)
- [ ] SSL certificates
- [ ] Backup system
- [ ] Monitoring dashboard
```

---

## **IDE COMMANDS & SHORTCUTS**

### **DEVELOPMENT WORKFLOW:**
```bash
# 1. START DEVELOPMENT
cd frontend && npm run dev          # Frontend @ localhost:3000
cd backend && python manage.py runserver  # Backend @ localhost:8000

# 2. DATABASE MANAGEMENT
python manage.py migrate           # Run migrations
python manage.py import_bikes      # Import bike data
python manage.py createsuperuser   # Create admin

# 3. CACHING
redis-cli monitor                  # Monitor Redis
python manage.py clear_cache       # Clear Django cache

# 4. TESTING
python manage.py test apps.bikes   # Run bike tests
npm test                           # Frontend tests
npm run lighthouse                 # Performance test

# 5. DEPLOYMENT
vercel --prod                      # Deploy frontend
git push origin main               # Trigger CI/CD
```

### **DEBUGGING COMMANDS:**
```bash
# Check API connectivity
curl http://localhost:8000/api/bikes/

# Check Redis connection
redis-cli ping

# Check MongoDB
mongo "mongodb+srv://..." --eval "db.bikes.count()"

# Health check
curl http://localhost:8000/health/

# Monitor logs
tail -f backend/logs/debug.log
```

---

## **EMERGENCY FIX PROTOCOL**

### **IF FRONTEND SHOWS "NO DATA":**
```typescript
// Step 1: Check API connectivity
const isBackendAlive = await api.healthCheck();

// Step 2: Fallback to local data if API down
if (!isBackendAlive) {
  console.warn('API offline, using local data');
  const localBikes = await import('@/data/bikes.json');
  // Show banner: "Showing cached data"
}

// Step 3: Implement service worker for offline
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
}
```

### **IF DATABASE CONNECTION FAILS:**
```python
# backend/utils/db_fallback.py
import psycopg2
from pymongo import MongoClient
import redis
from django.core.cache import cache

class DatabaseFallback:
    @staticmethod
    def check_connections():
        status = {
            'postgres': False,
            'mongodb': False,
            'redis': False
        }
        
        try:
            # Check PostgreSQL
            from django.db import connection
            connection.ensure_connection()
            status['postgres'] = True
        except:
            pass
            
        try:
            # Check MongoDB
            client = MongoClient(settings.MONGODB_URI, serverSelectionTimeoutMS=5000)
            client.server_info()
            status['mongodb'] = True
        except:
            pass
            
        try:
            # Check Redis
            cache.set('health_check', 'ok', timeout=10)
            status['redis'] = True
        except:
            pass
            
        return status
```

---

## **FINAL MASTER COMMAND FOR IDE**

```bash
# COMPLETE SYSTEM BOOTSTRAP COMMAND
./bootstrap.sh

# What it does:
# 1. Installs all dependencies (frontend + backend)
# 2. Sets up environment variables
# 3. Runs database migrations
# 4. Imports bike data to PostgreSQL + MongoDB
# 5. Starts Redis server
# 6. Launches Django dev server
# 7. Launches Next.js dev server
# 8. Opens browser to localhost:3000
# 9. Starts monitoring dashboard

# CREATE bootstrap.sh:
#!/bin/bash
echo "ðŸš€ MrBikeBD System Bootstrap"

# 1. Backend setup
cd backend
pip install -r requirements.txt
python manage.py migrate
python manage.py import_bikes
python manage.py runserver &

# 2. Frontend setup
cd ../frontend
npm install
npm run dev &

# 3. Redis
redis-server &

# 4. Open browser
sleep 5
open http://localhost:3000

echo "âœ… System ready at http://localhost:3000"
```

---

## **NEXT IMMEDIATE ACTION (START HERE):**

```python
# EXECUTE THESE 3 COMMANDS IN ORDER:

# 1. MIGRATE BIKE DATA (Most Critical)
cd backend
python scripts/migrate_bikes.py

# 2. GENERATE BASIC APIS
python scripts/generate_apis.py

# 3. TEST CONNECTION
curl -X GET "http://localhost:8000/api/bikes/" \
  -H "Content-Type: application/json"

# EXPECTED RESPONSE:
# {"count": 300, "results": [...], "next": null, "previous": null}
```

---

**CRITICAL REMINDER:** The system is currently **UI-ONLY**. Focus 100% on backend APIs for next 7 days. No new features until:
1. âœ… API endpoints working
2. âœ… Database populated  
3. âœ… Authentication functional
4. âœ… Frontend consuming real APIs
hello


